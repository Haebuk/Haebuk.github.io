<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>airflow on 지식 공유, 협업 ✈️ 성장</title>
        <link>https://Haebuk.github.io/tags/airflow/</link>
        <description>Recent content in airflow on 지식 공유, 협업 ✈️ 성장</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>ko-kr</language>
        <lastBuildDate>Fri, 14 Oct 2022 20:15:22 +0900</lastBuildDate><atom:link href="https://Haebuk.github.io/tags/airflow/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Airflow 정리</title>
        <link>https://Haebuk.github.io/p/airflow-%EC%A0%95%EB%A6%AC/</link>
        <pubDate>Fri, 14 Oct 2022 20:15:22 +0900</pubDate>
        
        <guid>https://Haebuk.github.io/p/airflow-%EC%A0%95%EB%A6%AC/</guid>
        <description>&lt;img src="https://Haebuk.github.io/p/airflow-%EC%A0%95%EB%A6%AC/AirflowLogo.png" alt="Featured image of post Airflow 정리" /&gt;&lt;h1 id=&#34;what-is-airflow&#34;&gt;What is Airflow?&lt;/h1&gt;
&lt;h2 id=&#34;core-components&#34;&gt;Core Components&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Web server: UI 담당 웹 서버&lt;/li&gt;
&lt;li&gt;Scheduler: 워크플로우 스케줄링&lt;/li&gt;
&lt;li&gt;Metastore: 메타데이터가 저장되는 데이터 베이스&lt;/li&gt;
&lt;li&gt;Executor: 작업이 어디서 실행될지 정의&lt;/li&gt;
&lt;li&gt;Worker: 작업이 실행되는 프로세스&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;dag&#34;&gt;DAG&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dag_id&lt;/code&gt;: 유니크한 dag 이름&lt;/li&gt;
&lt;li&gt;&lt;code&gt;start_date&lt;/code&gt;: dag가 처음 스케줄되는 시간. &lt;code&gt;datetime&lt;/code&gt; 모듈로 정의&lt;/li&gt;
&lt;li&gt;&lt;code&gt;schedule_interval&lt;/code&gt;: 스케줄되는 간격. cron으로 정의하거나 &lt;code&gt;&amp;quot;@daily&amp;quot;&lt;/code&gt;와 같이 정의&lt;/li&gt;
&lt;li&gt;&lt;code&gt;default_args&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;owner&lt;/code&gt;: &lt;code&gt;str&lt;/code&gt;, &lt;code&gt;&amp;quot;airflow&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;email_on_failure&lt;/code&gt;: &lt;code&gt;bool&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;email_on_retry&lt;/code&gt;: &lt;code&gt;bool&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;email&lt;/code&gt;: &lt;code&gt;str&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;retries&lt;/code&gt;: &lt;code&gt;int&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;retry_delay&lt;/code&gt;: &lt;code&gt;datetime.timedelta&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;catchup&lt;/code&gt;: airflow가 트리거하지 않았던 날짜에 대해 실행 여부, &lt;code&gt;False&lt;/code&gt;로 하는 것이 좋음&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;dagrun&#34;&gt;DAGrun&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;스케줄러가 DAGrun object 생성&lt;/li&gt;
&lt;li&gt;주어진 시간의 dag 정보를 담고 있는 인스턴스&lt;/li&gt;
&lt;li&gt;실행될 task들을 가지고 있음&lt;/li&gt;
&lt;li&gt;원자성, 멱등성&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;operator&#34;&gt;Operator&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Operator = Task&lt;/li&gt;
&lt;li&gt;실행하고자 하는 작업을 캡슐화했다고 생각하면 된다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;task_id&lt;/code&gt;: 하나의 dag내에서 유니크한 이름을 가져야 한다.&lt;/li&gt;
&lt;li&gt;종류
&lt;ul&gt;
&lt;li&gt;Action Operator: 실행 (bash)&lt;/li&gt;
&lt;li&gt;Transfer Operator: 전송 (mysql, postgres)&lt;/li&gt;
&lt;li&gt;Sensor Operator: 감지&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;how-airflow-works&#34;&gt;How Airflow works?&lt;/h1&gt;
&lt;h2 id=&#34;one-node-architecture&#34;&gt;One Node Architecture&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Web server가 metastore에서 메타데이터 정보를 가져온다.&lt;/li&gt;
&lt;li&gt;Schduler가 Metastore와 Executor에서 DAG, 작업을 트리거한다.&lt;/li&gt;
&lt;li&gt;Executor가 작업 업데이트를 metastore에 완료되었다고 업데이트한다.&lt;/li&gt;
&lt;li&gt;Executor에는 큐가 있는데, 실행이 정해진 순서대로 되게 한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;multi-nodes-architecture-celery&#34;&gt;Multi Nodes Architecture (Celery)&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Node1에는 웹서버, 스케줄러, 익스큐터가 있음&lt;/li&gt;
&lt;li&gt;Node2에는 메타스토어와 큐가 있음. 큐는 rabbit MQ나 redis 같은 서비스를 사용함&lt;/li&gt;
&lt;li&gt;워커 노드들에는 Airflow 워커들이 있음&lt;/li&gt;
&lt;li&gt;실행 방식은 1 노드 구조와 유사하나, 익스큐터는 외부 큐에 작업을 푸시한다.&lt;/li&gt;
&lt;li&gt;큐 내부에 있는 작업은 워커에 의해 풀 된다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;folder-dags&#34;&gt;folder dags&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;dags 폴더에 파일이 저장&lt;/li&gt;
&lt;li&gt;웹 서버와 스케쥴러가 이를 파싱함&lt;/li&gt;
&lt;li&gt;스케쥴러가 메타스토어에 dagrun object를 생성&lt;/li&gt;
&lt;li&gt;dag가 실행이 되어야 할 경우 스케줄러가 TaskInstance object를 메타스토어에 스케줄함&lt;/li&gt;
&lt;li&gt;TaskInstance를 익스큐터에 보냄&lt;/li&gt;
&lt;li&gt;실행 중에 메타스토어의 정보를 실행중으로 업데이트&lt;/li&gt;
&lt;li&gt;완료되면 메타스토어의 정보를 완료로 업데이트&lt;/li&gt;
&lt;li&gt;dagrun이 종료되었는지 검증&lt;/li&gt;
&lt;li&gt;웹서버가 metastore의 정보를 ui에 업데이트&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;caution&#34;&gt;caution&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;dag에 파일이 업데이트 되면 &lt;code&gt;dag_dir_list_interval&lt;/code&gt; 주기 후 (기본 5분) UI상에서 확인 가능하다.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;min_file_process_interval&lt;/code&gt; (기본 30초) dag를 파싱하는 시간. dag 코드가 업데이트 되도 해당 시간 후 반영된다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;commands&#34;&gt;Commands&lt;/h1&gt;
&lt;h2 id=&#34;useful-commands&#34;&gt;useful commands&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;airflow run&lt;/code&gt;: 하나의 task 인스턴스 실행&lt;/li&gt;
&lt;li&gt;&lt;code&gt;airflow list_dags&lt;/code&gt;: dag 목록&lt;/li&gt;
&lt;li&gt;&lt;code&gt;airflow dag_state&lt;/code&gt;: dag 상태&lt;/li&gt;
&lt;li&gt;&lt;code&gt;airflow task_state&lt;/code&gt;: task 상태&lt;/li&gt;
&lt;li&gt;&lt;code&gt;airflow test&lt;/code&gt;: 테스트&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;test&#34;&gt;test&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;$ airflow tasks test DAG_ID TASK_ID DATE&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;dependencies&#34;&gt;dependencies&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;task 디펜던시 줄 때 줄바꾸기&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;task1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;task2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;task3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;task3&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;task4&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;task5&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h1 id=&#34;dag-details&#34;&gt;DAG Details&lt;/h1&gt;
&lt;h2 id=&#34;date-options&#34;&gt;date options&lt;/h2&gt;
&lt;h3 id=&#34;start_date&#34;&gt;&lt;code&gt;start_date&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;DAG의 task들이 언제부터 트리거되고 스케줄되는지 시간을 정의.
&lt;ul&gt;
&lt;li&gt;ex) 2019-03-01로 정의했다면, 2019년 3월 1일 자정에 스케줄됨&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;python의 &lt;code&gt;datetime&lt;/code&gt; 모듈로 정의 가능&lt;/li&gt;
&lt;li&gt;과거나 미래로 설정 가능함
&lt;ul&gt;
&lt;li&gt;미래로 설정 시, 해당 시간이 될 때까지 기다림&lt;/li&gt;
&lt;li&gt;과거로 설정 시, 기다리지 않고 실행 가능. 그러나 &lt;code&gt;catchup=False&lt;/code&gt;로 주지 않으면 과거로 설정한 날짜로 부터 &lt;code&gt;schedule_interval&lt;/code&gt;마다 task instance가 실행되므로 주의&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;datetime.now()&lt;/code&gt;와 같이 동적으로 할당하지 말 것&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;schedule_interval&#34;&gt;&lt;code&gt;schedule_interval&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;start_date&lt;/code&gt;의 최소값으로 부터 트리거되는 시간 간격
&lt;ul&gt;
&lt;li&gt;같은 dag에서도 task 별로 &lt;code&gt;start_date&lt;/code&gt;를 따로 줄 수 있기 때문에 최소값으로 정의됨&lt;/li&gt;
&lt;li&gt;그러나 같은 dag내 task들은 같은 &lt;code&gt;start_date&lt;/code&gt;를 쓰는 것이 좋음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;cron expression이나 &lt;code&gt;datetime.timedelta&lt;/code&gt; 모듈로 정의 가능
&lt;ul&gt;
&lt;li&gt;cron을 쓰는 것이 더 정확한 표현을 할 수 있으므로 cron을 사용하는 것이 좋음&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;execution_date&#34;&gt;&lt;code&gt;execution_date&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;dag가 실행된 시각이 &lt;strong&gt;아님&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;start_date&lt;/code&gt; - &lt;code&gt;schedule_interval&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;end_date&#34;&gt;&lt;code&gt;end_date&lt;/code&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;dag/task가 더이상 스케줄되지 않는 시간&lt;/li&gt;
&lt;li&gt;기본값은 None&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;backfill&#34;&gt;Backfill&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;실행되지 않았던 dag/task를 실행하는 기능&lt;/li&gt;
&lt;li&gt;&lt;code&gt;catchup=True&lt;/code&gt;로 설정 시 수행&lt;/li&gt;
&lt;li&gt;&lt;code&gt;catchup=False&lt;/code&gt;로 설정 시 실행되지 않은 가장 마지막 dag/task만 실행하도록 되어 있음&lt;/li&gt;
&lt;li&gt;CLI를 통해 실행 가능. &lt;a class=&#34;link&#34; href=&#34;https://airflow.apache.org/docs/apache-airflow/stable/dag-run.html#backfill&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;airflow 공식문서&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;depends_on_past&#34;&gt;&lt;code&gt;depends_on_past&lt;/code&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;task 레벨에서 정의&lt;/li&gt;
&lt;li&gt;&lt;code&gt;default_args&lt;/code&gt;에 정의 해서 모든 task에도 적용 가능&lt;/li&gt;
&lt;li&gt;이전 dagrun의 특정 task가 실패했다면, 이번 dagrun에서 그 task가 실행되는 것을 막을 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;wait_for_downstream&#34;&gt;&lt;code&gt;wait_for_downstream&lt;/code&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;task 레벨에서 정의&lt;/li&gt;
&lt;li&gt;&lt;code&gt;default_args&lt;/code&gt;에 정의 해서 모든 task에도 적용 가능&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wait_for_downtstream&lt;/code&gt;이 정의된 task의 downstream task들이 이전 dagrun에서 완료될 때 까지 이번 dagrun 대기&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;dags-folder-structure&#34;&gt;DAGs folder structure&lt;/h2&gt;
&lt;h3 id=&#34;1-zip&#34;&gt;1. Zip&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;dag 파일은 zip 파일 root에 위치해야함&lt;/li&gt;
&lt;li&gt;모듈 디펜던시가 필요하면 virtualenv와 pip 사용&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-dagbag&#34;&gt;2. DAGBag&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;DAG 모음. 폴더 구조로 dag를 다룬다.&lt;/li&gt;
&lt;li&gt;dev/staging/prod와 같이 환경 분리에 이점이 있다&lt;/li&gt;
&lt;li&gt;dagbag이 깨지면 airflow UI상에서 에러가 뜨지 않고 웹서버 로그로만 확인 가능하므로 주의&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-airflowignore&#34;&gt;3. .airflowignore&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;.gitignore와 유사&lt;/li&gt;
&lt;li&gt;모든 dags 폴더에 넣는 것이 좋음&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;failure-detection&#34;&gt;Failure Detection&lt;/h2&gt;
&lt;h3 id=&#34;dags&#34;&gt;DAGs&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dagrun_timeout&lt;/code&gt;: dagrun이 타임아웃되는 시간. 스케줄된 dag만 해당하며(수동 실행은 해당되지 않음) 실행중인 dag의 수가 &lt;code&gt;max_active_runs&lt;/code&gt;와 일치하는 경우에만 해당&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sla_miss_callback&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;on_failure_callback&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;on_success_callback&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tasks&#34;&gt;Tasks&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;email&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;email_on_failure&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;email_on_retry&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;retries&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;retry_delay&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;retry_exponential_backoff&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;max_retry_delay&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;execution_timeout&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;on_failure_callback&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;on_success_callback&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;on_retry_callback&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;test-1&#34;&gt;Test&lt;/h1&gt;
&lt;h2 id=&#34;dag-validation-tests&#34;&gt;DAG validation tests&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;유효한지&lt;/li&gt;
&lt;li&gt;cycle이 없는지&lt;/li&gt;
&lt;li&gt;default arguments가 잘 설정됐는지&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;dagpipeline-definition-tests&#34;&gt;DAG/Pipeline Definition Tests&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;task의 숫자가 맞는지&lt;/li&gt;
&lt;li&gt;(로직이 아닌) task가 잘 정의 됐는지&lt;/li&gt;
&lt;li&gt;task의 upstream, downstream 디펜던시가 잘 정의됐는지&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;unit-tests&#34;&gt;Unit tests&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;로직 체크&lt;/li&gt;
&lt;li&gt;operator가 잘 동작되는지만 체크&lt;/li&gt;
&lt;li&gt;복잡한 로직을 airflow가 하게 두지 마라 (airflow는 오케스트레이션 툴이다)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;integration-tests&#34;&gt;Integration tests&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;task가 데이터를 잘 교환하는지&lt;/li&gt;
&lt;li&gt;task의 input 체크&lt;/li&gt;
&lt;li&gt;여러 task간 의존성 체크&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;end-to-end-pipeline-tests&#34;&gt;End to End Pipeline tests&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;결과가 올바른지&lt;/li&gt;
&lt;li&gt;전체 로직 체크&lt;/li&gt;
&lt;li&gt;성능 체크&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;local-executor&#34;&gt;Local Executor&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;병렬 실행 가능 (개발시 local executor 사용 권장)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;parallelism = 0&lt;/code&gt;: unlimit&lt;/li&gt;
&lt;li&gt;&lt;code&gt;parallelism &amp;gt; 0&lt;/code&gt;: limit
&lt;ul&gt;
&lt;li&gt;코어수 - 1로 설정하는 것을 권장&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dag_cuncurrency&lt;/code&gt;와 &lt;code&gt;max_active_runs_per_dag&lt;/code&gt; 옵션에 따라 dag간 task 실행 순서를 조정할 수 있다.
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dag_cuncurrency&lt;/code&gt;: dag내에서 동시에 실행 가능한 task의 수&lt;/li&gt;
&lt;li&gt;&lt;code&gt;max_active_runs_per_dag&lt;/code&gt;: 동시에 실행 시킬 수 있는 dag 수(backfill 일 때 주로 신경쓸 듯)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;subdags&#34;&gt;SubDAGs&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;유사한 DAG를 하나의 그룹으로 묶어 UI상에서 마치 하나의 DAG인 것 처럼 표시할 수 있음&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SubDagOperator&lt;/code&gt; 사용
&lt;ul&gt;
&lt;li&gt;기본 Executor는 &lt;code&gt;SequentialExecutor&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;main DAG가 모든 subDAG 들을 task로 관리&lt;/li&gt;
&lt;li&gt;Airflow UI는 오직 main DAG만 표시&lt;/li&gt;
&lt;li&gt;subDAG는 부모 DAG와 동일한 시각에 스케줄되어야 함. 그렇지 않으면 예상치 못한 결과를 낳을 수 있음&lt;/li&gt;
&lt;li&gt;데드락이 발생할 수 있음&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;branching&#34;&gt;Branching&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;DAG가 특정 task의 결과에 따라 경로를 선택할 수 있게끔 하는 것&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BranchPythonOperator&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BranchPythonOperator&lt;/code&gt;의 결과가 task_c를 반환하고 &lt;code&gt;BranchPythonOperator&lt;/code&gt;의 downstream으로 task_a, task_b, task_c가 있다면 task_c를 실행하고, a와 b는 스킵&lt;/li&gt;
&lt;li&gt;&lt;code&gt;depends_on_past=True&lt;/code&gt;로 지정시, a와 b는 실패 상태로 뜨기 때문에 다음 DAGrun은 실행되지 않음&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BranchPythonOperator&lt;/code&gt;에 empty path를 주면 의도하지 않은 결과를 줄 수 있기 때문에 반드시 주는 것이 좋다.
&lt;ul&gt;
&lt;li&gt;path를 스킵하고 싶다면 (task를 끝내고 싶다면) dummy task를 줘서 끝내자&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;마지막 task도 skipped로 뜨는 것을 막고 싶다면 마지막 task operator에 &lt;code&gt;trigger_rule=&#39;one_success&#39;&lt;/code&gt;추가&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;trigger-rule&#34;&gt;Trigger Rule&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;depends_on_past&lt;/code&gt;와 사용 가능&lt;/li&gt;
&lt;li&gt;upstream task중 skipped task가 있으면 &lt;code&gt;all_success&lt;/code&gt;와 &lt;code&gt;all_failed&lt;/code&gt;는 skipped 상태로 표시됨&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;kinds&#34;&gt;Kinds&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;all_success&lt;/code&gt;: upstream task가 모두 성공하면 run&lt;/li&gt;
&lt;li&gt;&lt;code&gt;all_failed&lt;/code&gt;: upstream task가 모두 실패하면 run&lt;/li&gt;
&lt;li&gt;&lt;code&gt;all_done&lt;/code&gt;: upstream task가 성공 유무와 관련없이 끝나면 run&lt;/li&gt;
&lt;li&gt;&lt;code&gt;one_failed&lt;/code&gt;: upstream task가 하나라도 실패해야 run&lt;/li&gt;
&lt;li&gt;&lt;code&gt;one_success&lt;/code&gt;: upstream task가 하나라도 성공해야 run&lt;/li&gt;
&lt;li&gt;&lt;code&gt;none_failed&lt;/code&gt;: upstream task가 failed가 없어야 run&lt;/li&gt;
&lt;li&gt;&lt;code&gt;none_skipped&lt;/code&gt;: upstream task가 skipped가 없어야 run&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dummy&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;variables&#34;&gt;Variables&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;metadata DB에 저장되는 값&lt;/li&gt;
&lt;li&gt;Key, value, Is encrypted로 구성&lt;/li&gt;
&lt;li&gt;JSON 형식 가능&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;templating&#34;&gt;Templating&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;placeholder &lt;code&gt;{{}}&lt;/code&gt; 를 사용하여 값을 대체&lt;/li&gt;
&lt;li&gt;Jinja template&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;macros&#34;&gt;Macros&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://airflow.apache.org/docs/apache-airflow/stable/templates-ref.html#macros&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://airflow.apache.org/docs/apache-airflow/stable/templates-ref.html#macros&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;xcoms&#34;&gt;XCOMs&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;task 간 메세지 공유&lt;/li&gt;
&lt;li&gt;key, value, timestamp로 구성&lt;/li&gt;
&lt;li&gt;value는 가벼워야 한다. (성능 문제)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xcom_push(key, value)&lt;/code&gt;로 metadata DB에 푸시
&lt;ul&gt;
&lt;li&gt;key: &lt;code&gt;returned_value&lt;/code&gt;, value: 리턴값&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;xcom_pull(key)&lt;/code&gt;로 받기
&lt;ul&gt;
&lt;li&gt;key를 명시하지 않으면 &lt;code&gt;returned_value&lt;/code&gt;가 기본값&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;triggerdagrunoperator&#34;&gt;TriggerDagRunOperator&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;다른 DAG(컨트롤러)의 조건에 따라 특정 DAG(타겟)를 시작하게 함&lt;/li&gt;
&lt;li&gt;branch나 subdag로는 너무 복잡해질때 사용&lt;/li&gt;
&lt;li&gt;컨트롤러는 타겟이 종료될 때 까지 기다리지 않음&lt;/li&gt;
&lt;li&gt;컨트롤러와 타겟은 독립적임&lt;/li&gt;
&lt;li&gt;컨트롤러의 히스토리에 관한 시각화는 제공되지 않음&lt;/li&gt;
&lt;li&gt;두 dag모두 스케줄되어야 함&lt;/li&gt;
&lt;li&gt;타겟 interval은 None이어야 함&lt;/li&gt;
&lt;li&gt;두 dag간에 메세지를 주고받을 수 있음(xcoms 대체)&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;externaltasksensor&#34;&gt;ExternalTaskSensor&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;DAG간 종속성 줄 때 사용&lt;/li&gt;
&lt;li&gt;예를 들어 DAG1(&lt;code&gt;t1 &amp;gt;&amp;gt; t2 &amp;gt;&amp;gt; t3&lt;/code&gt;), DAG2(&lt;code&gt;t3 &amp;gt;&amp;gt; t4 &amp;gt;&amp;gt; t5&lt;/code&gt;)가 있을 때 t3가 완료되면 (DAG1이 완료되면) DAG2가 실행되도록 한다. (t4부터)&lt;/li&gt;
&lt;li&gt;두 DAG는같은 스케줄이어야 함 (또는 &lt;code&gt;execution_delta&lt;/code&gt; 나 &lt;code&gt;execution_date_fn&lt;/code&gt; 파라미터 사용)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TriggerDagRunOperator&lt;/code&gt;와 쓰면 고장남
&lt;ul&gt;
&lt;li&gt;스케줄 인터벌 None이기 때문&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;logging&#34;&gt;Logging&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;airflow.cfg&lt;/code&gt;의 &lt;code&gt;base_log_folder&lt;/code&gt;: log 저장 경로&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fab_logging_level&lt;/code&gt;: flask app builder의 로깅 수준. (flask 기반 웹서버)&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;metrics&#34;&gt;Metrics&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Counters: 실패한 task 수&lt;/li&gt;
&lt;li&gt;Gauges: queued task 수&lt;/li&gt;
&lt;li&gt;Timers: task 완료까지의 밀리초&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
